\section{Architektura i przepływ danych}
\noindent
Węzeł pomiarowy (DHT11) wysyła ramki LoRaWAN metodą OTAA, a payload ma postać tekstu \texttt{T:x,H:y}. \\
\noindent
Serwer odbiorczy subskrybuje uplink z TTN przez MQTT, parsuje dane i zapisuje je do InfluxDB przez API HTTP v2. \\
\noindent
Grafana odczytuje dane z InfluxDB i generuje alerty, które są przekazywane webhookiem do aplikacji Flask.

\subsection{Węzeł LoRaWAN}
\noindent
Pomiar wykonywany jest cyklicznie, a dane są kodowane do bufora tekstowego i wysyłane jako payload uplinku.
\begin{minted}{cpp}
int len = snprintf(mydata, PAYLOAD_SIZE, "T:%d,H:%d", DHT.temperature, DHT.humidity);
LMIC_setTxData2(1, (uint8_t*)mydata, len, 1);
\end{minted}
\noindent
Użyte biblioteki firmware: \texttt{lmic}, \texttt{hal/hal}, \texttt{SPI}, \texttt{DFRobot\_DHT11}. \\
\noindent
Najważniejsze parametry: \texttt{TX\_INTERVAL} (interwał wysyłki), \texttt{PAYLOAD\_SIZE} (bufor payloadu), \texttt{DHT11\_PIN} i \texttt{ALARM\_LED\_PIN} (piny sprzętowe), \texttt{CMD\_LED\_ON/OFF} (kody downlink), mapowanie \texttt{lmic\_pins}.

\begin{minted}{cpp}
#define DHT11_PIN 7
#define ALARM_LED_PIN 8
#define CMD_LED_OFF 0x00
#define CMD_LED_ON  0x01
const unsigned TX_INTERVAL = 5;
const lmic_pinmap lmic_pins = { .nss = 10, .rxtx = LMIC_UNUSED_PIN, .rst = LMIC_UNUSED_PIN, .dio = {2, 3, LMIC_UNUSED_PIN} };
\end{minted}
\noindent
Obsługa downlink realizuje proste sterowanie diodą alarmową.

\begin{minted}{cpp}
uint8_t cmd = data[0];
if (cmd == CMD_LED_ON) {
		digitalWrite(ALARM_LED_PIN, HIGH);
} else if (cmd == CMD_LED_OFF) {
		digitalWrite(ALARM_LED_PIN, LOW);
}
\end{minted}

\subsection{Uplink i zapis do bazy}
\noindent
Po odebraniu wiadomości z TTN następuje parsowanie i zapis do InfluxDB w formacie Line Protocol.
\begin{minted}{python}
payload_from_device = data["uplink_message"]["decoded_payload"]["text"]
temp, hum = parse_data(payload_from_device)
line_protocol = f"measurements_ttn,device={device_id} T={temp},H={hum}"
requests.post(url, data=line_protocol, headers=headers)
\end{minted}
\noindent
Warstwa zapisu korzysta z tokenu administracyjnego oraz bucketu wskazanego w zmiennych środowiskowych.
\begin{minted}{python}
INFLUX_HOST = os.getenv("INFLUX_HOST", "http://localhost:8086")
INFLUX_TOKEN = os.getenv("INFLUXDB_INIT_ADMIN_TOKEN", "")
INFLUX_ORG = os.getenv("INFLUXDB_INIT_ORG", "pwr")
INFLUX_BUCKET = os.getenv("INFLUXDB_INIT_BUCKET", "pwr")
\end{minted}

\subsection{Alert i downlink}
\noindent
Alert Grafany trafia do webhooka, a system publikuje komendę downlink w TTN.
\begin{minted}{python}
if status == "firing":
		send_downlink(CMD_LED_ON)
elif status == "resolved":
		send_downlink(CMD_LED_OFF)
\end{minted}
\noindent
Publikacja downlink obejmuje kodowanie payloadu do base64 oraz wysyłkę na temat TTN.
\begin{minted}{python}
topic = f"v3/{APP_ID}@ttn/devices/{DEV_EUI}/down/push"
payload_bytes = bytes([command])
payload_b64 = base64.b64encode(payload_bytes).decode("ascii")
client.publish(topic, json.dumps(downlink_msg))
\end{minted}

\subsection{Przepływ danych -- kroki}
\noindent
1. Odczyt DHT11 i zbudowanie payloadu. \\
\noindent
2. Uplink przez LoRaWAN do TTN. \\
\noindent
3. Odbiór MQTT i parsowanie przez serwer aplikacyjny. \\
\noindent
4. Zapis punktu do InfluxDB. \\
\noindent
5. Wizualizacja w Grafanie i generacja alertu. \\
\noindent
6. Wywołanie webhooka i publikacja downlink do urządzenia.
